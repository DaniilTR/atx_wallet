# 3. Безопасное хранение seed и «поэтический пароль» (улучшенный план)

Цель: перейти на **полностью локальный (cold/local-only)** режим, где **seed никогда не покидает устройство** (Android/iOS), и **никогда не хранится в открытом виде**.

Web (Chrome) используется **только для DEV-тестов** и не является целевой защищённой платформой.

---

## 3.1. Ключевая модель защиты (многоуровневая)

1. **Seed хранится только в зашифрованном виде (ciphertext).**
2. Seed шифруется с помощью **симметричного ключа (DEK)** с использованием **AEAD**:
    - `AES-256-GCM` (по умолчанию),
    - либо `XChaCha20-Poly1305` / `ChaCha20-Poly1305` (альтернатива).
3. **DEK вычисляется из пользовательского «поэтического пароля» через KDF**:
    - предпочтительно `Argon2id`,
    - fallback: `PBKDF2-HMAC-SHA256` с усиленными параметрами (только если Argon2id недоступен/нестабилен).
4. **Зашифрованный контейнер** (метаданные + ciphertext) хранится в **защищённом хранилище платформы** (Keychain/Keystore).
5. Для защиты от подмены/переноса контейнера между контекстами используется **AAD (Associated Authenticated Data)**.

---

## 3.2. Платформы и область применения

### Production (релиз)

- **Android**: да
- **iOS**: да

### DEV-тесты

- **Web (Chrome)**: да, но **без претензии на безопасность**.
    - На Web запрещено “настоящим образом” гарантировать защиту seed на уровне OS (модель браузера другая).
    - Seed на Web допускается:
        - только для тестовых кошельков,
        - только при включенном DEV-режиме,
        - без remote-API для хранения seed,
        - и с явным предупреждением “не использовать реальные средства”.

---

## 3.3. Используемые механизмы в Flutter

### Защищённое хранилище (Android/iOS)

- `flutter_secure_storage` как обёртка над:
    - Android Keystore + EncryptedSharedPreferences (или эквивалент),
    - iOS Keychain.

**Политика:** в `flutter_secure_storage` хранится только **зашифрованный контейнер**, а не открытые секреты.

### KDF + шифрование

- KDF:
    - `Argon2id` (предпочтительно),
    - fallback: `PBKDF2-HMAC-SHA256`.
- Шифрование:
    - `cryptography` (AEAD: AES-GCM / ChaCha20-Poly1305),
    - либо `pointycastle` при необходимости.

---

## 3.4. Пользовательский «пароль»

### Требования к паролю

- Пользователь вводит пароль **дважды** при создании кошелька (защита от опечатки).
- В UI отображаем рекомендации:
    - не использовать известные строки,

### Нормализация пароля (важно: стабильность)

Нормализация должна быть **минимальной, предсказуемой и версионируемой**:

- Unicode Normalization: `NFKC` (или `NFC`, но выбрать один и не менять).
- **Не** делать “умное” удаление пробелов или приведение к нижнему регистру, если это может менять смысл.
- Хранить `normVersion` в контейнере, чтобы правила не сломали доступ после обновлений.

---

## 3.5. Схема хранения (контейнер)

### 1) Создание кошелька

1. Генерируем mnemonic (BIP-39).
2. Генерируем `salt` (16–32 байта CSPRNG).
3. Генерируем `nonce` (для AEAD, например 12 байт для AES-GCM).
4. Нормализуем пароль (см. выше).
5. Вычисляем ключ через KDF:
- **Argon2id**:
    - вход: `passwordNormalized`, `salt`, параметры (`m`, `t`, `p`),
    - выход: 32 байта ключа.
- **PBKDF2 fallback**:
    - HMAC-SHA256, `iterations` (усиленные), output 32 байта.
1. Шифруем mnemonic через AEAD (например, AES-256-GCM):
    - `ciphertext, tag = AEAD_Encrypt(key, nonce, plaintextMnemonic, aad)`
2. Сохраняем в `flutter_secure_storage` единый JSON-контейнер.

### 2) Доступ к кошельку (разблокировка)

1. Проверяем наличие контейнера в secure storage.
2. Пользователь вводит пароль.
3. Нормализуем пароль согласно `normVersion`.
4. Восстанавливаем ключ KDF по `salt` и параметрам из контейнера.
5. Пытаемся расшифровать AEAD:
    - если auth tag не сходится → пароль неверный (или данные повреждены).
6. После успешной расшифровки mnemonic живет в памяти **только в рамках сессии**.

---

## 3.6. Формат контейнера (предложение)

Храним один объект (пример, поля можно уточнить):

```json
{
  "v": 1,
  "platform": "android|ios",
  "createdAt": "2026-02-18T00:00:00Z",

  "normVersion": 1,

  "kdf": {
    "alg": "argon2id",
    "saltB64": "...",
    "params": { "m": 65536, "t": 3, "p": 1, "dkLen": 32 }
  },

  "cipher": {
    "alg": "aes-256-gcm",
    "nonceB64": "..."
  },

  "aad": {
    "appId": "com.example.atx_wallet",
    "schema": "wallet-seed",
    "userScope": "default"
  },

  "encryptedSeedB64": "..."
}
```

### AAD (Associated Data)

В AAD (или при формировании AAD-строки) фиксируем:

- `applicationId / packageName`
- `schemaVersion`
- `userScope` (если есть несколько профилей)
- опционально `chain/network` (если у вас разные сети)

**Зачем:** это снижает риск “подмены/переноса” контейнера между контекстами.

---

## 3.7. Политики безопасности (обязательные)

### Никогда не храним seed открыто

Seed-фраза **не хранится в plaintext**:

- ни в файлах,
- ни в SharedPreferences,
- ни в базе,
- ни в логах,
- ни в crash-репортах,
- ни в аналитике.

### В памяти (runtime)

- seed и ключи держим **минимально возможное время**,
- не кешируем в singleton/state,
- по возможности работаем с `Uint8List`,
- не выводим в debug-print даже в dev (лучше иметь отдельный "masking logger").

### Защита от перебора (online brute-force)

- После N неверных попыток:
    - вводим задержку (exponential backoff),
    - временно блокируем попытки.
- По возможности требуем системную аутентификацию (biometric/lockscreen) для критичных действий (показ seed, экспорт).

### UI-защита

- Запрет скриншотов на экранах, где отображается seed/ключи.
- При копировании в clipboard — предупреждение + автоочистка буфера (если реализуемо).

---

## 3.8. DEV-режим (Chrome) — строгие ограничения

Web/Chrome используется только для разработки, чтобы можно было запускать:
`flutter run -d chrome`

Политика DEV:

1. DEV-хранилище seed на web:
    - допускается только для тестовых аккаунтов,
    - только при `DEV_MODE=true`,
    - **без удалённого API**, которое сохраняет seed на сервер.
2. DEV-эндпоинты (если они существуют в сервере):
    - должны быть выключены по умолчанию,
    - доступны только в локальной среде (localhost) или под строгой авторизацией.
3. В production конфигурации web-функции, связанные с seed, отключены.

---

## 3.9. Параметры KDF (черновые, требуют бенчмарка)

Параметры подбираем по принципу: **на слабом устройстве ~200–500 мс на derivation**, без OOM.

- Argon2id (пример):
    - `m`: 64–128 MB
    - `t`: 2–4
    - `p`: 1
- PBKDF2 fallback (пример):
    - `iterations`: 200k–600k (под бенчмарк)
    - `dkLen`: 32

Параметры обязательно храним в контейнере для будущих миграций.

---

## 3.10. Ключевые моменты для релиза

- DEV-хранилище (plaintext JSON / DEV API) **не должно быть включено в release** ни при каких условиях.
- В release сборках Android/iOS seed хранится только в зашифрованном контейнере в secure storage.
- Для web (если собирается) seed-функции отключены или явно маркированы как DEV-only.