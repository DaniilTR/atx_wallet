# Реализация seed фразы

# Проект крипто кошелька для BNB Smart Chain Testnet

**Архитектура, стандарты и реализация защиты seed‑фразы**

В данном документе я описываю архитектуру и принципы работы нашего крипто кошелька, который:

- работает для сети **BNB Smart Chain Testnet**;
- строго следует международным стандартам (BIP‑39, BIP‑32, BIP‑44);
- обеспечивает **совместимость** блокчейн кошелька со сторонними кошельками;
- реализует **многоуровневую защиту seed‑фразы**, включая «поэтический пароль».

---

# Постановка задачи и требования

Для выполнения и реализации нашей разработке мы формулируем основные требования такие как:

1. **Генерация seed‑фразы**
    - 1.1. Seed‑фраза должна полностью соответствовать стандарту [BIP‑39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki): длина, энтропия, словари, checksum.
    - 1.2. По сгенерированной seed‑фразе любой сторонний кошелёк (TrustWallet, MetaMask и т.п.) должен быть способен восстановить тот же кошелёк, то есть обеспечивается совместимость.
2. **Производные данные из seed‑фразы**
    - По seed‑фразе я по стандартам получаю:
        - приватные ключи,
        - публичные ключи,
        - адрес(а) кошелька
3. **Безопасное хранение seed‑фразы**
    - 3.1. Использовать защищённые хранилища платформ (Keystore, Keychain, Secure Storage и аналоги) — seed никогда не хранится в открытом виде.
    - 3.2. Доступ к seed‑фразе возможен только через **«поэтический пароль»** — строку стиха длиной 16–30 символов, из которой через KDF (Argon2id) получается ключ шифрования.
4. **Интеграция с BNB Smart Chain Testnet**
    - 4.1. Реализую получение и отображение баланса для блокчейн сети (tBNB, и остальные токены стандарта ERC20).
    - 4.2. Поддерживать приём и отправку токенов а так же их отображение входящих/исходящих транзакций.

---

## 1. Стандарты: BIP‑39 + BIP‑32/BIP‑44 и BSC

### 1.1. Seed‑фраза по BIP‑39

В качестве основы генерации seed‑фразы я использую стандарт **BIP‑39**. Для реализации в Flutter/Dart мы будем опираться на готовые библиотеки :

- `bip39` (Dart),
- либо аналогичные пакеты (`flutter_bip39` и т.п.).

**Параметры, которым я следую:**

- Длина фразы: 12 слова.
- Соответствующая энтропия: 128 бит.
- Словарь: английский (`english.txt` из BIP‑39) — это важно для совместимости с MetaMask, TrustWallet и другими кошельками.

**Генерация и валидация:**

```dart
import 'package:bip39/bip39.dart' as bip39;

// 128 бит энтропии => 12 слов
final mnemonic = bip39.generateMnemonic(strength: 128);

// Проверка валидности (при импорте)
final isValid = bip39.validateMnemonic(mnemonic);

```

Таким образом, мы обеспечиваем:

- соответствие стандарту BIP‑39;
- возможность импортировать seed‑фразу в сторонние кошельки и обратно.

### 1.2. Деривация ключей: BIP‑32/BIP‑44 для BNB Smart Chain

BNB Smart Chain (mainnet и testnet) — это EVM‑совместимая сеть. В архитектуре мы используем стандартную схему:

- Деривационный путь: `m / 44' / 60' / 0' / 0 / 0` — классический путь для Ethereum и большинства EVM‑сетей.
- Для BSC мы используем **тот же путь** `m/44'/60'/0'/0/0`, что позволяет получить тот же адрес, что и в MetaMask при выборе сети BSC.

Для этого в Dart мы применяем библиотеки:

- `bip32` — для BIP‑32/44;
- `web3dart` — для работы с ключами и адресами EVM.

**Схема:**

1. Из mnemonic получаю seed (BIP‑39 → 512‑битное значение).
2. Seed → master key (BIP‑32).
3. По BIP‑44 деривирую путь `m/44'/60'/0'/0/0`.
4. Получаем приватный ключ (32 байта).
5. Из приватного ключа получаем публичный ключ и Ethereum‑совместимый адрес (0x...).

Упрощённый пример (псевдокод):

```dart
import 'package:bip39/bip39.dart' as bip39;
import 'package:bip32/bip32.dart' as bip32;
import 'package:web3dart/web3dart.dart';

String generateMnemonic() => bip39.generateMnemonic(strength: 128);

EthPrivateKey derivePrivateKeyFromMnemonic(String mnemonic) {
  final seed = bip39.mnemonicToSeed(mnemonic);
  final root = bip32.BIP32.fromSeed(seed);

  // Путь для Ethereum/BSC
  final child = root.derivePath("m/44'/60'/0'/0/0");

  final privKey = EthPrivateKey.fromHex(child.privateKey!.toHex());
  return privKey;
}

EthereumAddress deriveAddress(EthPrivateKey privKey) {
  return privKey.address;
}

```

Так мы гарантируем:

- **совместимость**: один и тот же mnemonic и путь будем давать тот же адрес, что и в популярных кошельках (MetaMask, TrustWallet и др.) при использовании BSC;
- строгое следование BIP‑39/BIP‑44.

---

## 2. Подключение к сети BNB Smart Chain Testnet

Сеть, которую мы используем — **BNB Smart Chain Testnet**.

В качестве RPC‑узла можно использовать:

- `https://bsc-testnet.bscdataseed.com`,
- или любой другой публичный/частный RPC‑endpoint (Ankr, QuickNode и т.д.).

### 2.1. Инициализация клиента web3dart

```dart
import 'package:web3dart/web3dart.dart';
import 'package:http/http.dart' as http;

final client = Web3Client(
  '<https://bsc-testnet.bscdataseed.com>', // RPC для BSC Testnet
  http.Client(),
);

```

### 2.2. Получение баланса (tBNB)

```dart
Future<EtherAmount> getBalance(EthereumAddress address) {
  return client.getBalance(address); // баланс в Wei
}

// Перевод в BNB:
final balanceInBNB = balance.getValueInUnit(EtherUnit.ether);

```

Этот баланс мы затем отображаем в пользовательском интерфейсе.

### 2.3. Отправка транзакций (tBNB)

```dart
Future<String> sendBNB({
  required EthPrivateKey fromKey,
  required EthereumAddress to,
  required EtherAmount amount,
}) async {
  final txHash = await client.sendTransaction(
    fromKey,
    Transaction(
      to: to,
      value: amount, // EtherAmount.fromUnitAndValue(EtherUnit.ether, 0.01)
      // gasPrice, gas, nonce могу задать явно или дать web3dart посчитать
    ),
    chainId: 97, // chainId BNB Smart Chain Testnet
  );
  return txHash;
}

```

Замечание:

`chainId = 97` соответствует BNB Smart Chain Testnet, что важно для защиты от replay‑атак и корректной подписи транзакций.

---

## 3. Безопасное хранение seed и «поэтический пароль»

Ключевая идея нашей работы это **многоуровневая защита seed‑фразы**:

1. Seed хранится только в зашифрованном виде.
2. Внутренний контейнер (blob) с seed шифруется симметричным ключом.
3. Симметричный ключ вычисляется из «поэтического пароля» с помощью KDF (предпочтительно Argon2id).
4. Зашифрованный контейнер хранится в защищённом хранилище платформы.

### 3.1. Используемые механизмы в Flutter

Для реализации мы используем следующие подходы и библиотеки:

- **Защищённое хранилище:**
    - `flutter_secure_storage` — обёртка над:
        - Android Keystore / EncryptedSharedPreferences,
        - iOS/macOS Keychain,
        - аналогичными механизмами на других платформах.
- **KDF + шифрование:**
    - предпочитаем Argon2id как современный KDF, но при его недоступности возможен fallback на PBKDF2 с усиленными параметрами ;
    - для симметричного шифрования:
        - `cryptography` (AES‑256‑GCM, ChaCha20‑Poly1305),
        - либо `pointycastle`.

### 3.2. Схема хранения

1. **Пользовательский ввод:**
    - Пользователь придумывает и вводит **«поэтический пароль»** (строка из стихотворения длиной 16–30 символов).
    - Ввод подтверждается повтором для исключения опечаток.
2. **Создание кошелька:**
    - Я генерирую mnemonic (BIP‑39).
    - Генерируем `salt` (16–32 случайных байта).
    - Нормализую пароль (регистры, пробелы, Unicode NFC/NFKC).
    - Применяю KDF Argon2id:
        
        ```dart
        final secretKey = await argon2idKeyDerivation(
          password: poeticPasswordNormalized,
          salt: salt,
          iterations: ..., // параметр t
          memory: ...,     // параметр m (~1 GiB в атакующем сценарии, меньше — на устройстве)
          parallelism: ...,
          length: 32,      // 256 бит ключа
        );
        
        ```
        
    - Шифрую mnemonic, например, AES‑256‑GCM:
        
        ```dart
        final encrypted = await aesGcmEncrypt(
          key: secretKey,
          plaintext: utf8.encode(mnemonic),
        );
        // encrypted включает: nonce, ciphertext, tag
        
        ```
        
    - В `flutter_secure_storage` сохраняю JSON‑объект:
        
        ```json
        {
          "salt": "<base64>",
          "nonce": "<base64>",
          "ciphertext": "<base64>",
          "tag": "<base64>",
          "kdf": "argon2id",
          "kdf_params": {
            "t": ...,
            "m": ...,
            "p": ...
          }
        }
        
        ```
        
3. **Доступ к кошельку (разблокировка):**
    - При запуске приложения я проверяю, есть ли сохранённый `encryptedBlob`.
    - Пользователь вводит «поэтический пароль».
    - Пароль нормализуется.
    - На основе сохранённой `salt` и параметров KDF заново вычисляется ключ.
    - Производится попытка расшифровать контейнер; если тег аутентификации не сходится — пароль неверен.

**Принципиальные моменты:**

- Seed‑фраза **никогда не хранится в открытом виде**:
    - ни в файловой системе,
    - ни в SharedPreferences,
    - ни в базе данных,
    - ни в логах/краш‑репортах.
- В оперативной памяти:
    - seed и ключи присутствуют только на время выполнения операций (деривация приватных ключей, создание транзакций),
    - по возможности временные буферы затираются (в Dart это ограничено, но мы исключаем лишнее логирование и кеширование секретов).

---

## 4. Пользовательские сценарии

### 4.1. Создание нового кошелька

Мы реализуем стандартный сценарий «мастера»:

1. Пользователь заходит в приложение (после базовой авторизации).
2. Если кошелёк ещё не создан:
    - Шаг 1: генерация seed‑фразы (BIP‑39, например, 12 слов).
    - Шаг 2: показ seed‑фразы с предупреждениями:
        - «Запишите на бумагу/металл»,
        - «Не делитесь ни с кем»,
        - «Не делайте скриншоты».
    - Шаг 3: проверка — пользователь вводит/выбирает слова в правильном порядке.
    - Шаг 4: ввод «поэтического пароля» (16–30 символов).
    - Шаг 5: шифрование seed и сохранение зашифрованного контейнера в защищённом хранилище.
3. После завершения:
    - seed‑фраза в памяти удаляется (по возможности),
    - приватный ключ и адрес при необходимости могут быть сразу деривированы и адрес сохранён как публичная информация.

### 4.2. Разблокировка уже существующего кошелька

- При запуске я проверяю наличие зашифрованного контейнера.
- Если он есть:
    - отображается экран ввода «поэтического пароля»;
    - при успешной дешифрации:
        - деривирую приватный ключ и адрес;
        - инициализирую web3‑клиент;
        - загружаю баланс и (опционально) историю транзакций.

---

## 5. Работа с балансом и транзакциями

### 5.1. Получение и отображение баланса

На базе `web3dart` мы реализуем сервис, который:

1. Имеет доступ к:
    - `Web3Client`,
    - `EthPrivateKey` и `EthereumAddress`.
2. Периодически или по запросу (pull‑to‑refresh) вызывает:
    
    ```dart
    final balance = await client.getBalance(address);
    final balanceInBNB = balance.getValueInUnit(EtherUnit.ether);
    
    ```
    
3. Передаёт это значение в UI через:
    - `ChangeNotifier` / `ValueNotifier`,
    - `Stream`,
    - или любой другой state‑management (Provider, Riverpod, BLoC).

В интерфейсе мы отображаем:

- полный адрес в сокращённом виде (`0x1234...ABCD`),
- текущий баланс в tBNB.

### 5.2. Отправка транзакций на сторонние адреса

Сценарий:

1. Пользователь нажимает «Отправить» / «Send».
2. Вводит:
    - адрес получателя (валидируя формат `0x` + 40 шестнадцатеричных символов),
    - сумму в BNB.
3. Приложение:
    - конвертирует сумму в Wei (`EtherAmount.fromUnitAndValue`),
    - при необходимости запрашивает `gasPrice` и `gasLimit` (через `estimateGas`),
    - формирует и отправляет транзакцию через `sendTransaction`.

Перед отправкой мы отображаем пользователю:

- адрес получателя,
- сумму перевода,
- комиссию (gas * gasPrice в BNB),
- итоговую сумму списания.

---

## 6. SLIP‑39 и мульти‑сиг (теоретическая часть)

В теоретической части работы мы рассматриваем также:

- стандарт **SLIP‑39** (Shamir Secret Sharing для seed‑фразы),
- сценарии m‑of‑n восстановления (когда seed разбит на несколько физических фрагментов).

На практике в первой версии реализации:

- Мы оставляем **базовую схему BIP‑39** + локальное многослойное шифрование seed;
- поддержку SLIP‑39 планирую как расширение, так как:
    - реализация требует дополнительных криптографических модулей (Shamir Secret Sharing) в Dart;
    - интеграция сильно усложняет UX и тестирование.

---

## 7. Архитектура модулей и интеграция в приложение

В рамках репозитория (Flutter‑приложение) мы создаем следующую структуру:

- `lib/crypto/mnemonic_service.dart`
    - генерация и валидация seed‑фразы (BIP‑39).
- `lib/crypto/key_derivation.dart`
    - деривация master seed → BIP‑32 → путь BIP‑44 `m/44'/60'/0'/0/0`,
    - получение приватных ключей и адресов для BNB Smart Chain Testnet.
- `lib/crypto/secure_storage_service.dart`
    - работа с `flutter_secure_storage`,
    - сохранение/чтение зашифрованного контейнера (salt, nonce, ciphertext, tag, kdf_params).
- `lib/wallet/wallet_manager.dart`
    - публичный API для остального приложения:
        
        ```dart
        class WalletManager {
          Future<String> createNewWallet(String poeticPassword);
          Future<void> importWallet(String mnemonic, String poeticPassword);
          Future<EthereumAddress> getAddress(String poeticPassword);
          Future<EtherAmount> getBalance(String poeticPassword);
          Future<String> sendBNB({
            required String poeticPassword,
            required EthereumAddress to,
            required EtherAmount amount,
          });
        }
        
        ```
        
    - Внутри:
        - дешифровка контейнера по «поэтическому паролю»,
        - получение seed и деривация приватного ключа/адреса,
        - взаимодействие с `Web3Client` для BSC Testnet.
- Интеграция в UI:
    - после авторизации пользователя (уже реализованной части), приложение:
        - проверяет наличие созданного кошелька;
        - если кошелька нет — запускает мастер создания;
        - если кошелёк есть — просит «поэтический пароль» и затем отображает экран с балансом и отправкой.

---

## 8. Итоги

В работе я:

- опираюсь на стандарты BIP‑39/BIP‑32/BIP‑44 и обеспечиваю совместимость seed‑фразы со сторонними кошельками;
- настраиваю работу **строго с сетью BNB Smart Chain Testnet**, включая верный `chainId` и RPC‑endpoint;
- реализую многоуровневую архитектуру защиты:
    1. персистентность только в виде зашифрованного контейнера;
    2. шифрование с ключом на основе «поэтического пароля» через современный KDF;
    3. хранение зашифрованных данных в защищённых хранилищах платформы;
- проектирую удобные пользовательские сценарии:
    - создание кошелька,
    - ручное резервное копирование seed‑фразы,
    - разблокировка по поэтическому паролю,
    - просмотр баланса и отправка транзакций.

Эта архитектура позволяет совместить требования безопасности, совместимость с индустриальными стандартами и поддержку конкретной сети (BNB Smart Chain Testnet), что и является ключевой целью моего проекта.